#!nsh
# Un comment and use set +e to ignore and set -e to enable 'exit on error control'
set +e
# Un comment the line below to help debug scripts by printing a trace of the script commands
#set -x

#
# TAP startup script.
#
# NOTE: COMMENT LINES ARE REMOVED BEFORE STORED IN ROMFS.
#

# V1 HW Serial map:
# /dev/ttyS0: GPS
# /dev/ttyS1: GIMBAL
# /dev/ttyS2: nsh shell / console
# /dev/ttyS3: payload
# /dev/ttyS4: esc bus
# /dev/ttyS5: RC input

# V2 HW Serial map:
# /dev/ttyS0: GPS
# /dev/ttyS1: GIMBAL
# /dev/ttyS2: esc bus / console (mux s7)
# /dev/ttyS3: payload
# /dev/ttyS4: RC input

# V3 HW Serial map:
# /dev/ttyS0: GPS / J32   			(USART1)
# /dev/ttyS1: OFS / J34 			(USART2)
# /dev/ttyS2: OFDM / J47			(USART3)
# /dev/ttyS3: GIMBAL / J29 (wired as CAN)	(UART4)
# /dev/ttyS4: esc bus TX:J15 RX:J18  		(UART5)
# /dev/ttyS5: RC  / J28 Receiver 		(USART6)
# /dev/ttyS6: Smart Battery (Not connected on H520S-000-R1)(UART7)
# /dev/ttyS7: console / J23			(UART8)

# TAP_V4 HW Serial map:
# /dev/ttyS0: GPS     		(USART1)
# /dev/ttyS1: Sonar(Front)	(USART2)
# /dev/ttyS2: OF+Sonar		(USART3)
# /dev/ttyS3: Camera  		(UART4)
# /dev/ttyS4: esc bus 		(UART5)
# /dev/ttyS5: Avoid/Telem	(USART6)
# /dev/ttyS6: Smart Battery	(UART7)
# /dev/ttyS7: console		(UART8)

if ver hwcmp TAP_V3 TAP_V4
then
#
# Mount the procfs.
#
	mount -t procfs /proc
fi

#
# Start CDC/ACM serial driver
#
sercon

#
# Configuration defaults
#
# When the system configuration changes this variable
# needs to be incremented. This will not reset the
# calibration but will reset the system tuning and gains
# to reflect the new defaults
#
set DEFAULTS_VER 93
set RELEASE_VER 0  # no release version

# Log file location
set LOG_FILE /fs/microsd/bootlog.txt
if ver hwcmp TAP_V1
then
	set DATAMAN_OPT -r
fi
set START_LOGGER 0
set PARAM_FILE /fs/microsd/params

#
# Start the ORB (first app to start)
# tone_alarm and tune_control
# is dependent.
#
uorb start

#
# Try to mount the microSD card.
#
if mount -t vfat /dev/mmcsd0 /fs/microsd
then
	if hardfault_log check
	then
		if hardfault_log commit
		then
			hardfault_log reset
		fi
	fi

	echo "microSD present"
	unset DATAMAN_OPT
	set START_LOGGER 1

else
	if mkfatfs /dev/mmcsd0
	then
		if mount -t vfat /dev/mmcsd0 /fs/microsd
		then
			echo "microSD card formatted"
			unset DATAMAN_OPT
		else
			echo "ERROR [init] Format failed"
			#tune_control play -t 17
			set LOG_FILE /dev/null
			set PARAM_FILE /dev/null
		fi
	else
		set LOG_FILE /dev/null
		set PARAM_FILE /dev/null
# microSD not present, shutdown
		usleep 3000000
		reboot shutdown
	fi
fi

#
# Start the MTD
#
mtd start

#
# Load parameters
#

if ver hwcmp TAP_V2 TAP_V3 TAP_V4
then

	# now load from SD card, which can override the temp calib params
	param select ${PARAM_FILE}
	# we need to use param import (instead of load), because load will cause a reset
	if param load
	then
	else
		# Param load failed
		# wipe the SD card to restore the system
		mount -t vfat /dev/mmcsd0 /fs/microsd

		param reset

		param save
	fi

	# load the temperature calibration data from EEPROM.
	param import /fs/mtd_caldata

else
# tap v1
	if param load
	then
	else
		param reset
	fi
fi

unset PARAM_FILE

if ver hwcmp TAP_V2 TAP_V3 TAP_V4
then
	camera_trigger start
fi

#
# Start system state indicator
#
if ver hwcmp TAP_V4
then
	rgbled_pwm start
fi

#
# Set parameters and env variables for selected AUTOSTART
#
if param compare SYS_AUTOSTART 0
then
	if ver hwcmp TAP_V4
	then
		param set SYS_AUTOSTART 4100
	else
		param set SYS_AUTOSTART 6021
	fi
	param set SYS_AUTOCONFIG 1
fi

#
# Activate hardware in the loop mode using param SYS_HITL = 1.
#
if param compare SYS_HITL 1
then
	set HITL_ON yes
else
	set HITL_ON no
fi

#
# This is to migrate everyone from 6001 to param 6021.
# TODO: remove this again once enough time has passed
#
if param compare SYS_AUTOSTART 6001
then
	if ver hwcmp TAP_V4
	then
		param set SYS_AUTOSTART 4001
	else
		param set SYS_AUTOSTART 6021
	fi
fi

#
# This is to migrate everyone from 4001 to param 4100.
#
if param compare SYS_AUTOSTART 4001
then
	if ver hwcmp TAP_V4
	then
		param set SYS_AUTOSTART 4100
	fi
fi
#
# Set AUTOCNF flag to use it in AUTOSTART scripts
#
if param compare SYS_AUTOCONFIG 1
then
	# Wipe out params except RC*, TC_* (temperature calibration) and flight time
	param reset_nostart RC* TC_* LND_FLIGHT_T_*
	set AUTOCNF yes
else
	set AUTOCNF no
fi

set NEW_DEFAULTS no

if param compare SYS_PARAM_VER ${DEFAULTS_VER}
then
else
	echo "Switched to different parameter version. Resetting parameters."
	set NEW_DEFAULTS yes
fi

# Check if release version train changed
if param compare SYS_RELEASE_VER ${RELEASE_VER}
then
else
	echo "Switched to different firmware release. Resetting parameters."
	set NEW_DEFAULTS yes
fi

#
# Set default values
#
set VEHICLE_TYPE none
set MIXER none
set OUTPUT_MODE none
set PWM_OUT none
set PWM_RATE none
set PWM_DISARMED none
set PWM_MIN none
set PWM_MAX none
set FMU_MODE pwm
set MAV_TYPE none
set FAILSAFE none
set GIMBAL_TTY /dev/ttyS1
set OFDM_TTY /dev/ttyS2
set ESC_TTY /dev/ttyS4

if ver hwcmp TAP_V2
then
	set ESC_TTY /dev/ttyS2
fi

if ver hwcmp TAP_V3 TAP_V4
then
	set GIMBAL_TTY /dev/ttyS3
fi

# Start canned airframe config
sh /etc/init.d/rc.autostart

#
# Override RC loss parameter
# This parameter has been opened up for a use-case with 3DR. However, we want
# to make sure, that it always defaults to `1`. This means the external
# application will have to change the parameter after every reboot.
#
param set COM_RC_LOSS_MAN 1

#
# If autoconfig parameter was set, reset it and save parameters
#
if [ ${AUTOCNF} == yes ]
then
	param set SYS_AUTOCONFIG 0
fi
unset AUTOCNF

if [ ${NEW_DEFAULTS} == yes ]
then
	param set SYS_PARAM_VER ${DEFAULTS_VER}
	param set SYS_RELEASE_VER ${RELEASE_VER}
	param save
	set NEW_DEFAULTS no
	reboot
fi

#
# Set default output if not set
#
if [ ${OUTPUT_MODE} == none ]
then
	if [ ${USE_IO} == yes ]
	then
		set OUTPUT_MODE io
	else
		set OUTPUT_MODE fmu
	fi
fi

send_event start

#
# Check if we should start a thermal calibration
#
set DO_TEMP_CALIB 0
set TEMP_CALIB_ARGS ""
if param compare SYS_CAL_GYRO 1
then
	set TEMP_CALIB_ARGS "${TEMP_CALIB_ARGS} -g"
	param set SYS_CAL_GYRO 0
	set DO_TEMP_CALIB 1
fi
if param compare SYS_CAL_ACCEL 1
then
	set TEMP_CALIB_ARGS "${TEMP_CALIB_ARGS} -a"
	param set SYS_CAL_ACCEL 0
	set DO_TEMP_CALIB 1
fi
if param compare SYS_CAL_BARO 1
then
	set TEMP_CALIB_ARGS "${TEMP_CALIB_ARGS} -b"
	param set SYS_CAL_BARO 0
	set DO_TEMP_CALIB 1
fi


if [ ${DO_TEMP_CALIB} == 0 ]
then

	if [ ${HITL_ON} == no ]
	then
		set GPS_PORT /dev/ttyS0

		if param compare GPS_FIXPOS_RTK 1
		then
			if ver hwcmp TAP_V2
			then
				# Start the Fixposition RTK GPS on Real Sense port on H520
				set GPS_PORT /dev/ttyS3
			fi
		fi

		# Start GPS
		gps start -d ${GPS_PORT}

		unset GPS_PORT

	fi

	# waypoint storage
	# REBOOTWORK this needs to start in parallel
	dataman start ${DATAMAN_OPT}

fi

#
# Allocate the 3 PWM
# one for landing gear in group 0 chan 0
# two for Sonar in group 1 chan 0 and 1.
# chan 1 will be reconfigured as capture, but ONLY
# after the PWM rates are set because rates can only
# be set on all channels in a group.
#
fmu mode_pwm3

if [ ${HITL_ON} == no ]
then
	if ver hwcmp TAP_V1
	then
	# On TAP-V1 use 400 Hz PWM output for landing gear
		pwm rate -c 1 -r 400
	else
	# Use 50 Hz PWM output for landing gear
	# Set g 1 (Sonar) to 20 Hz which has the side effect of
	# setting the other group:g 1 (landing gear) to the default 50 Hz
		pwm rate -g 1 -r 20
	fi
	#
	# Load the gear mixer onto fmu
	#
	if mixer load /dev/px4fmu /etc/mixers/gear.mix
	then
		echo "INFO  [init] Mixer: gear on /dev/px4fmu"
	else
		echo "ERROR [init] Error loading mixer: gear"
		echo "ERROR [init] Error loading mixer: gear" >> $LOG_FILE
	fi

	#
	# Set Landing gear pwm configuration directly for the only channel we use
	# such that landing gear lowers on kill switch lockdown
	pwm disarmed -c 1 -p 1500
	pwm failsafe -c 1 -p 1000
fi

#
# Start the RC input driver
#
rc_input start



# make sure to start temperature calibration after the sensors
if [ "x${TEMP_CALIB_ARGS}" != "x" ]
then
	usleep 100000
	send_event temperature_calibration ${TEMP_CALIB_ARGS}
fi
unset TEMP_CALIB_ARGS



if [ ${HITL_ON} == no ]
then
	sh /etc/init.d/rc.sensors
	commander start
else
	sh /etc/init.d/rc.sensors_hil
	commander start --hil
fi

#
# Start CPU load monitor
#
load_mon start

#
# Play startup tune
#
if [ ${NEW_DEFAULTS} == yes ]
then
	# TODO: play update tune?
else
	tune_control play -t 1 -s 30
fi

# mavlink baudrate for Gimbal UART
if param compare SYS_COMPANION 57600
then
	set BAUDRATE 57600
else
	set BAUDRATE 500000
fi

# FIXME: for now we just want to make sure mavlink always runs with version 2,
# later move this to a proper place
param set MAV_PROTO_VER 2

# mavlink rate depends on baudrate
if ver hwcmp TAP_V4
then
	set MAV_RATE 40000
else
	set MAV_RATE 8000
fi

# starts a full mavlink instance for the gimbal port on TAP_V3 hardware
if ver hwcmp TAP_V3 TAP_V4
then
	# mavlink instance for the gimbal port
	mavlink start -r ${MAV_RATE} -d ${GIMBAL_TTY} -m config -b ${BAUDRATE}
	mavlink stream -d ${GIMBAL_TTY} -s SYSTEM_TIME -r 0.5
	if fmu is_ofdm
	then
		# mavlink instance for the OFDM port
		mavlink start -r ${MAV_RATE} -d ${OFDM_TTY} -m config -b ${BAUDRATE}
		mavlink stream -d ${OFDM_TTY} -s SYSTEM_TIME -r 0.5
	fi
	# mavlink instance for the USB port
	mavlink start -r 800000 -d /dev/ttyACM0 -m config -x
else
	# multiplex mavlink 2 & ymavlink on the gimbal serial
	gimbal_protocol_splitter start ${GIMBAL_TTY}
	# seems we need to start vmount before mavlink (probably due to some ioctl's)
	vmount start -d /dev/ymavlink -b ${BAUDRATE}

	# run mavlink (the same instance) on USB and gimbal port
	if [ ${HITL_ON} == no ]
	then
		set MAVLINK_DEV /dev/mavlink_dup
		mavlink_dup start -d ${MAVLINK_DEV}
		mavlink_dup add -d /dev/mavlink -b ${BAUDRATE}
		mavlink_dup add -d /dev/ttyACM0 -p
		mavlink start -r ${MAV_RATE} -d ${MAVLINK_DEV} -m config -b ${BAUDRATE}
		mavlink stream -d ${MAVLINK_DEV} -s SYSTEM_TIME -r 0.5
	else
		set MAVLINK_DEV /dev/mavlink
		mavlink start -r 20000 -d ${MAVLINK_DEV} -m config -b ${BAUDRATE}
		mavlink stream -d /dev/mavlink -s SYSTEM_TIME -r 0.5
		mavlink start -r 800000 -d /dev/ttyACM0 -b 921600 -m config -x
	fi


	mavlink stream -d ${MAVLINK_DEV} -s SYSTEM_TIME -r 0.5
	mavlink stream -d ${MAVLINK_DEV} -s ACTUATOR_CONTROL_TARGET0 -r 5.0
	mavlink stream -d ${MAVLINK_DEV} -s ALTITUDE -r 5.0
	mavlink stream -d ${MAVLINK_DEV} -s ATTITUDE -r 5.0
	mavlink stream -d ${MAVLINK_DEV} -s ATTITUDE_TARGET -r 5.0
	mavlink stream -d ${MAVLINK_DEV} -s ATTITUDE_QUATERNION -r 5.0
	mavlink stream -d ${MAVLINK_DEV} -s GLOBAL_POSITION_INT -r 50.0
	mavlink stream -d ${MAVLINK_DEV} -s HIGHRES_IMU -r 10.0
	mavlink stream -d ${MAVLINK_DEV} -s LOCAL_POSITION_NED -r 10.0
	mavlink stream -d ${MAVLINK_DEV} -s POSITION_TARGET_GLOBAL_INT -r 5.0
	mavlink stream -d ${MAVLINK_DEV} -s SERVO_OUTPUT_RAW_0 -r 5.0
	mavlink stream -d ${MAVLINK_DEV} -s SERVO_OUTPUT_RAW_1 -r 5.0
	mavlink stream -d ${MAVLINK_DEV} -s TIMESYNC -r 1.0
	unset MAVLINK_DEV
fi
unset MAV_RATE

#
# Logging
#
if ver hwcmp TAP_V2
then
		if [ ${HITL_ON} == yes ]
		then
			# prevent starting logger on H520 in HITL mode - not enough memory
			set START_LOGGER 0
			echo "logger: Not enough RAM in H520 HITL to start logger"
		fi
fi

if [ ${START_LOGGER} == 1 ]
then
	set LOGGER_ARGS ""
	if param compare SDLOG_MODE 1
	then
		set LOGGER_ARGS "-e"
	fi
	if param compare SDLOG_MODE 2
	then
		set LOGGER_ARGS "-f"
	fi
	if param compare SDLOG_MODE 3
	then
		set LOGGER_ARGS "-f"
	fi
	logger start -b 10 -q 3 -t -m file ${LOGGER_ARGS}
	unset LOGGER_ARGS
fi

unset START_LOGGER
unset BAUDRATE

#
# Fixed wing setup
#
if [ ${VEHICLE_TYPE} == fw ]
then

	if [ ${MIXER} == none ]
	then
		# Set default mixer for fixed wing if not defined
		set MIXER AERT
	fi

	if [ ${MAV_TYPE} == none ]
	then
		# Use MAV_TYPE = 1 (fixed wing) if not defined
		set MAV_TYPE 1
	fi

	param set MAV_TYPE ${MAV_TYPE}

	# Load mixer and configure outputs
	sh /etc/init.d/rc.interface

	# Start standard fixedwing apps
	sh /etc/init.d/rc.fw_apps
fi

#
# Multicopters setup
#
if [ ${VEHICLE_TYPE} == mc ]
then

	if [ ${MIXER} == none ]
	then
		echo "INFO  [init] Mixer undefined"
	fi

	if [ ${MAV_TYPE} == none ]
	then
		# Use mixer to detect vehicle type
		if [ ${MIXER} == quad_x -o ${MIXER} == quad_+ ]
		then
			set MAV_TYPE 2
		fi
		if [ ${MIXER} == quad_w ]
		then
			set MAV_TYPE 2
		fi
		if [ ${MIXER} == quad_h ]
		then
			set MAV_TYPE 2
		fi
		if [ ${MIXER} == tri_y_yaw- -o ${MIXER} == tri_y_yaw+ ]
		then
			set MAV_TYPE 15
		fi
		if [ ${MIXER} == hexa_x -o ${MIXER} == hexa_+ ]
		then
			set MAV_TYPE 13
		fi
		if [ ${MIXER} == hexa_cox ]
		then
			set MAV_TYPE 13
		fi
		if [ ${MIXER} == octo_x -o ${MIXER} == octo_+ ]
		then
			set MAV_TYPE 14
		fi
	fi

	# Still no MAV_TYPE found
	if [ ${MAV_TYPE} == none ]
	then
		echo "WARN  [init] Unknown MAV_TYPE"
		param set MAV_TYPE 2
	else
		param set MAV_TYPE ${MAV_TYPE}
	fi

	# Load mixer and configure outputs
	if [ ${HITL_ON} == yes ]
	then
		# Override mixer to quad_x for HITL simulation
		set MIXER quad_x
	fi
	sh /etc/init.d/rc.interface


	if [ $DO_TEMP_CALIB == 0 ]
	then
		# Start standard multicopter apps
		sh /etc/init.d/rc.mc_apps
	fi
fi

unset MIXER
unset MAV_TYPE
unset OUTPUT_MODE
unset HITL_ON

# There is no further script processing, so we can free some RAM
# XXX potentially unset all script variables.
unset DO_TEMP_CALIB

if param compare SYS_COMPANION 1921600
then
	mavlink start -r 200000 -b 921600 -d /dev/ttyS1
else

	if param compare SYS_COMPANION 2921600
	then
		mavlink start -r 200000 -b 921600 -d /dev/ttyS2
		mavlink boot_complete
		exit
	else
		#
		# Start the navigator
		#
		navigator start
	fi
fi

set REALSENSE_PORT /dev/ttyS3

if ver hwcmp TAP_V3
then
	set REALSENSE_PORT /dev/ttyS1
fi

if ver hwcmp TAP_V3
then
	realsense start -d ${REALSENSE_PORT}
fi

# There is no further script processing, so we can free some RAM
# XXX potentially unset all script variables.
unset REALSENSE_PORT
unset DEFAULTS_VER
unset RELEASE_VER
#unset TUNE_ERR
unset LOG_FILE
unset DATAMAN_OPT

# Boot is complete, inform MAVLink app(s) that the system is now fully up and running
mavlink boot_complete
